# Task 0

Тут без комментариев, основную функцию нашел, гидра ее хорошо декомпилировала. Программа падает, потому что `user_input` не аллоцирован.
![[assets/task0.png]]

# Task 1

Я ленивый и просто решил прочитать почарово все дерево условий - понятно было, что этот код - loop-unrolled версия `strcmp()` для всей строки.
![[assets/task1_ifs.png]]
Я просто решил вставить флаг, который у меня получился - все работает:
![[assets/task1.png]]

# Task 2

Переменная `__s` ссылалась на неизвестный `PTR_DAT_00104060`. В функции `main()` было понятно, что `__s` - строка, поэтому у `PTR_DAT_00104060` и внутри лежащего блока я поменял тип данных на `string`, после чего обнаружил зашифрованную строку:
![[assets/task2_str.png]]

Далее смотрим на код: у нас выполняется какой-то цикл, и после его выполнения `iVar5 == iVar4 + -1`. Если `iVar5 == 0x539` (то есть, `iVar5 == 1337`), значит `iVar4 == 1338`.
`0x52dU` это `1325` в десятичном представлении, пора писать скрипт на python, который xor'нет каждый символ в строке с `iVar4` и вычтет `0x52dU`:
![[assets/task2.png]]

# Task 4

Сначала мне удалось понять, что в итоге передо мной python, посмотрев строчки:
![[assets/task4_main.png]]

Погуглив, мне удалось понять, что питоновские бинари надо распаковывать, при этом у линукса в бинаре торчит много чего сжатого через zlib:
![[assets/task4_zlib.png]]

Погуглив, я нашел `pyinstxtractor.py` [скрипт](https://github.com/extremecoders-re/pyinstxtractor/blob/master/pyinstxtractor.py), он распаковал бинарь следующим образом:
![[assets/task4_extract.png]]

Внутренности следующие:
![[assets/task4_extdir.png]]

Первым делом посмотрим `task_4.pyc` и вот ответ:
![[assets/task4.png]]

Программа завершилась без ошибок по Ctrl+C:
![[assets/task4_exit.png]]

# Task 5

Для начала пришлось прочитать статейки про реверсинг golang бинарей, попробовать разного рода скрипты, например, [отсюда](https://habr.com/ru/articles/758310/). Не получив успеха, я спустя денб догадался нагуглить уже полноценный [экстеншен](https://github.com/mooncat-greenpy/Ghidra_GolangAnalyzerExtension), который упростил мне жизнь, благо он был собран под новейшую Ghidra 10.4.

Тут же была обнаружена функция `main.printFlag()`, чуть-чуть убравшись в ней, код выглядел вот так:
![[task5_main.png]]

Рассмотрев `PTR_DAT_004dae30`, я обнаружил, что это строка, в которой каждый символ имеет размер 8 байт. Таких пучка данных два, располагаются друг за другом, суммарная их длина удивительным образом была 38 8-байтовых чара. В коде функции каждый такой чар ксорится с числом 7, пора писать скрипт, благо я для себя открыл возможность копировать сырые байты из Ghidra в виде python byte string:
![[task5.png]]

# Task 6

Покопавшись в коде, мне удалось понять, что передо мной V language (потом это было еще сказано на лабе и не раз), можно понять это, если проанализировать вывод `strings task_6`:
![[assets/task6_v.png]]

Примерно такая логика у `main()` функции после уборки:
![[assets/task6_main.png]]

Приубравшись в `do_main()` функции, в последнем цикле выполняется цепочка операций над каждым символом строки с ввода:
![[assets/task6_for.png]]

Функция `print_string()` действительно работает в соответствии с V language `print()` функцией, я решил ее поподробнее разобрать, так как надо действительно убедиться, что она принтит:
![[assets/task6_printstring.png]]

В начале проводится проверка строчки, уточняется ее актуальная длина (предположу, что для printable chars), и выполняется `v_print()`, которая вызывает сисколл с `id=1`:
![[assets/task6_vprint.png]]

Это подтверждают сорцы встроенной библиотеки V и таблица сисколлов под linux:
![[assets/task6_vsrc.png]]

Логика цикла `for` работает таким образом, решил переписать на python и протестировать: 
![[assets/task6.png]]

# Task 7

В секции `modinfo` лежит флаг:
![[assets/task7.png]]

# Task 8

Я обрадовался, быстро узнав, что передо мной модуль для ядра linux, в котором вызывается некая функция `intro_read()`, вызывающая в себе уже известную всем `copy_to_user()`. Мне удалось сначала довести функцию до такого вида:
![[assets/task8_code.png]]

Перед нами две строки длиной 39 (с учетом null character), вторая состоит из "сырых" байтиков, предлагаю написать python скрипт для расшифрования. Во-первых, проверим, что строки действительно совпадают по длине через assert, а затем перепишем код уже на python:
![[assets/task8.png]]
