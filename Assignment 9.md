# Algorithm

Функция `main()` декомпилировалась хорошо, внутри нее видно, что на вход программе в качестве первого аргумента подается username, а в качестве второго - serial. У серийника проверяется длина - нужно 26 символов, после чего он парсится в 3 инта по формату `%x-%x-%x`, то есть 3 hex integer, разделенных дефисом.
Послу чего вызывается функция `validate()`:
![[assets/a9_main.png]]

Функция валидации выглядит вот так:
![[assets/a9_validate.png]]

`get_reversed_username_md5()` выглядит так:
![[a9_md5.png]]
tldr: она соответствует такому коду на питоне:

```python
def get_reversed_username_md5(username: str) -> bytes:
    if len(username) > 128:
        exit(2)
    
    tmp = username + username[::-1]
    buf = tmp.encode() + bytes([0] * (256 - len(tmp)))
    return hashlib.md5(buf).digest()
```

non-tldr: делает следующее:
1. У нас два буфера: `username_cpy[128]`, `buf[256]`
2. `username` проверяется, что у него длина не превышает 128 чаров, иначе `exit(2)`
3. Буфер `buf` зануляется
4. Посредством вызова функции `stpcpy()` в `username_cpy` копируется username, возвращается поинтер на `\0` чар скопированной строки и сохраняется в `dest_right`
5. В буфер `buf` копируется `username` посредством вызова `memcpy()`
6. Далее `username_cpy` разворачивается, получается развернутая строка
7. В буфер `buf` аппендится `username_cpy`
8. Теперь в `buf` лежит `<username><emanreus>\0\0\0\0\0\0\0\0\0...\0`, и от такого буфера длиной в 256 байт берется `md5` и записывается в `md5_res`

Для того, чтобы функция выглядела нормально, пришлось отредачить стекфрейм до вот такого вида:
![[assets/a9_stackframe.png]]

Вернемся к `validate()`, после действий с md5 вызывается функция `encode()` 2 раза, в нее поочередно передаются статические `DAT`-массивы:
![[assets/a9_validate.png]]

Тело функции `encode()` следующее:
![[assets/a9_encode.png]]

Здесь два цикла, в каждом из которых происходит следующее:
```C
do {
tmp1 = bits1_count(*(uint *)((long)raw_data + i) & (uint)serial_part_);
tmp2 = bits1_count(*(uint *)((long)raw_data2_ + i) & serial_part_1);
i = i + 4;
loop1 = loop1 * 2 ^ (tmp1 ^ tmp2) & 1;
} while (i != 128);
```

То есть на каждом шаге из обоих статических массивов берется по 4 байтика, кастятся в `uint`, далее побитово & с serial или `*serial_part` или `*(serial_part + 1)`;
затем считается количество битиков, установленных в `1`, и сохраняются в `tmp`-переменную. Далее переменная loop обновляется как в коде выше.

В самом конце значения `*serial_part` и `*(serial_part + 1)` **переписываются**!
```C
*serial_part = loop1;
serial_part[1] = loop2;
```

То есть, возвращаясь к `validate()` снова:
![[assets/a9_validate.png]]

Замечу, что:
1. После первого вызова` encode()` перепишутся `serial[0]` и `serial[1]`
2. Второй раз `encode()` запустится с переданным `serial + 1`, то есть с уже измененным `serial[1]` в качестве `serial_part_`, и пока неизмененным `serial[2]` в качестве `serial_part_1`
3. После второго вызова `encode()` перепишутся `serial[1]` и `serial[2]`

Finally, md5 у нас длиной 16 байт, делится на 4 `uint`, три из которых сравниваются с обновленным серийником.

# Thoughts about guessing username-serial pair

Как оказалось, мне потом другой чел скинул, "обычная лаба" является [таской с root-me](https://www.root-me.org/en/Challenges/Cracking/ELF-x64-CrackMe2), у которой **предпоследняя сложность**, и которую решило **125** человек со всего мира за все время :) И к сведению в интернете нету решений для нее, а чтобы его получить, надо самому решить на root-me.

Какие есть мысли по поводу брутфорсинга:

1. В самой таске просят найти серийник для username = `root-me`
2. Брутфорсить md5 для серийника - это бред, так как хеш создан для того, чтобы подбирать его было крайне тяжело.
3. Остается вариант брутфорсить серийник, но и тут у нас в алгоритме используется пара чисел из серийника, они перекрещиваются друг с другом, в итоге перебирать придется в худшем случае пару интов, то бишь `UINT_MAX^2`. Оптимизировать это смысла не сильно много имеет:
   - Я попробовал один инт зафиксировать и перебрать для другого инта, это заняло у меня где-то 2.5 часа вычислений, код на С. Перебирать` 2.5h * UINT_MAX` - крайне долго, и оптимизации в 30, в 100 раз тут не сыграют особо роли - 20е декабря точно наступит раньше :) Альтернативный, рабочий вариант был - **наныть на то, чтобы я писал этот параграф**, а не ревершенный алгоритм шифрования :)

Касательно реверсинга алгоритма какие есть мысли:

1. Была изначально мысль прокинуть серийник `00000000-00000000-00000000`, тогда и `encode()` будет записывать нули в пару чисел серийника, однако, md5 с leading zeroes встречается только максимум с первыми 6 нулями, а нам хотелось бы 12. Ну немного быстрее будет брутфорсинг, возможно. Искать md5 с бОльщим количесвтом нулей - это надо кластер из миллиона видюх покупать и искать.
2. Думаю, не зря дали юзернейм root-me - для него могли подготовить статические массивчики, и по идее можно подобрать такой серийник, чтобы внутри вот этой операции у нас после битового `&` не пропадали биты `1`:
```C
bits1_count(*(uint *)((long)raw_data + i) & (uint)serial_part_);
```
3. В целом посмотреть на эти 4 больших статических массива, возможно, там есть что-то закономерное:
![[assets/a9_statarrays.png]]
	note из лс с Данияром

Я проскиммил массивы, и на глаз пока не нашел каких-то крутых закономерностей... Но верю, что там что-то да есть.